Design Document
Vinh Vu
Darena Soukkhaseum

1. High Level Objective
	The problem with o161 we are trying to address is the fact that the system has minimal support for running executables. It has very little support for multi-tasking. Multiple system calls that help constitute a multi-tasking OS are either missing or incomplete and it was our job to implement them.

2. Process Structure
	For our design, we aimed for simplicity in order to have as close to a full project
	as possible. We chose to use the common hack of implementing the processes by adding 
	necessary fields to the thread structure and treating it as a process.
	- pid
	- parentpid
	- exit status
	- exit code
	- process lock
	
	We implemented a global process array (an array of threads) as our process table.
	(extern struct thread* proctable[];)
	
	We defined a limit to our table to limit the amount of processes at one time at 256
	(#define MAX_RUNNING_PROCESSES 256) which could be changed later. 
	
	Pids are chosen in thread_create by looping through the process array until an empty 
	spot is found. Once a spot is found, the index of that spot becomes the process pid.
	If no spot is found, we return an error.
	
	Answer this:
	can two different user-level processes (or user-level threads, if you choose to 
	implement them) find themselves running a system call at the same time?
	
3. System call implementations
	a) sys_execv()
	Execv.c references runprogram.c as a basis but should be modified to start processes properly.
	Programs started by runprogram should contain standard file descriptors available as opposed to their current unavailability.
	
	Sys_execv() will take a new process, execute it, and replace the current existing address space with that of the new 			executable's.
	
	Sys_execv() is, at its very core, runprogram() except it comes from userspace, goes into the ernel, and returns back to 		userspace while managing the memory that travels between the two spaces.
	
	Sys_execv() also takes an argument vector. The process is as such:
		1) Sys_execv() copies arguments from user space into the kernel buffer. 
		2) The executable is opened then an address space is created and the elf is loaded into it.
		3) Execv copies arguments from kernel buffer into user stack
		4) Once it is all finished it warps back to usermode using md_usermode
		
	
	
4. Pros and Cons
	Pros)
		
	Cons)
		a) sys_execv() does not address all the error codes required. We could not figure out the 

5. Alternatives
